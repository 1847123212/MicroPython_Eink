#! /usr/bin/python3

# Convert a font C source file to a binary file.
# Files created by GLCD Font Creator http://www.mikroe.com/glcd-font-creator/
# The binary file format includes a 4 byte header. This contains two bytes to signify a font file
# followed by the font heaight and width in pixls. The code attempts two ways of deducing these.
# Files produced by the GLCD Font Creator have a '//GLCD FontSize'  comment line which species these.
# This isused if it exists. However some files on the website lack this and have an initial record
# header_written into the data: this is used if necessary.

# Usage:
# ./CfontToBinary -i Arial16x16.c -o arial16x16.bin
import argparse

def process(infile, outfile, sourcefile):
    phase = 0
    chars_processed = 0
    header_written = False
    for line in infile:
        if phase == 0:
            start = line.find('//GLCD FontSize')
            if start >= 0:                          # Found the font size: parse line
                start = line.find(':')
                line = line[start +1:]
                operator = line.find('x')
                if operator > 0 :
                    horiz = int(line[ : operator])
                    vert = int(line[operator +1 :])
                    c = bytearray([0x3f, 0xe7, horiz, vert])
                    outfile.write(c)                # Write out our header
                    print("Wrote ", [int(x) for x in c])
                    header_written = True
                    phase = 1
            elif line.find('{') >= 0:
                phase = 1
        if phase == 1:                           # Skip to 1st data after '{'
            start = line.find('{')
            if start >= 0:
                line = line[start +1:]
                phase = 2
        if phase == 2:
            if not (line == '' or line.isspace()):
                comment = line.find('//')
                if comment > 0 :
                    line = line[:comment]
                hexnums = line.split(',')
                if header_written:              # Ignore manually entered header data
                    if len(hexnums) > 5:
                        phase = 3               # Real font data will have many more fields per line
                else:
                    if len(hexnums) <= 5:
                        nums = [x for x in hexnums if not x.isspace()]
                        horiz = nums[1]
                        vert = nums[2]
                        c = bytes((0x3f, 0xe7, int(horiz, 16), int(vert, 16)))
                        outfile.write(c)
                        print("Wrote ", [int(x) for x in c])
                        header_written = True
                    else:
                        break                   # No header data
        if phase == 3:                          # Process data until '}'
            end = line.find('}')
            if end > 0 :
                line = line[:end]
                phase = 4
            comment = line.find('//')
            if comment > 0 :
                line = line[:comment]
            hexnums = line.split(',')
            if hexnums[0] != '':
                for hexnum in [x for x in hexnums if not x.isspace()]:
                    outfile.write(bytes((int(hexnum, 16),)))
                chars_processed += 1
    if phase == 4 :
        print("Characters in font = ", chars_processed)
    else:
        print(''.join(("File: '", sourcefile, "' is not a valid C font file")))

def load_c(sourcefile, destfile):
    try:
        with open(sourcefile, 'r') as f:
            with open(destfile, 'wb') as outfile:
                process(f, outfile, sourcefile)
    except OSError as err:
        print(err)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(__file__, description="Convert C font generated by GLCD font creator to binary.\nSample usage:\n ./CfontToBinary -i Arial16x16.c -o arial16x16.bin")
    parser.add_argument("--outfile", "-o", help="Path and name of output file", required=True)
    parser.add_argument("--infile", "-i", help="Path and name of C font file", required=True)
    args = parser.parse_args()
    load_c(args.infile, args.outfile)
